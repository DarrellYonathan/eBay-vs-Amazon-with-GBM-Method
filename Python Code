# Referensi :
# https://scipy-cookbook.readthedocs.io/items/BrownianMotion.html
# https://jtsulliv.github.io/stock-movement/
# https://finance.yahoo.com/quote/EBAY?p=EBAY&.tsrc=fin-srch
# https://finance.yahoo.com/quote/AMZN?p=AMZN&.tsrc=fin-srch
# by Darrell Yonathan / 1706042825

import csv
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()

from math import sqrt
from scipy.stats import norm

priceE = []
dateE = []
priceA = []
dateA = []

tahun = 1999
with open('EBAY1.csv') as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=',')
    line_count = 0
    temp = 0
    for row in csv_reader:
        if line_count == 0:
            line_count += 1
        else:
            
            if line_count % 12 == 0:
                temp = float(temp / 12)
                priceE.append(temp)
                dateE.append(tahun)
                tahun += 1
                temp = 0
            else:
                temp += float(row[1])
            line_count += 1
            
tahun  = 1999
with open('AMZN.csv') as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=',')
    line_count = 0
    temp = 0
    for row in csv_reader:
        if line_count == 0:
            line_count += 1
        else:
            
            if line_count % 12 == 0:
                temp = float(temp / 12)
                priceA.append(temp)
                dateA.append(tahun)
                tahun += 1
                temp = 0
            else:
                temp += float(row[1])
            line_count += 1

def brownian(x0, n, dt, delta, out=None):
    """
    Generate an instance of Brownian motion (i.e. the Wiener process):

        X(t) = X(0) + N(0, delta**2 * t; 0, t)

    where N(a,b; t0, t1) is a normally distributed random variable with mean a and
    variance b.  The parameters t0 and t1 make explicit the statistical
    independence of N on different time intervals; that is, if [t0, t1) and
    [t2, t3) are disjoint intervals, then N(a, b; t0, t1) and N(a, b; t2, t3)
    are independent.
    
    Written as an iteration scheme,

        X(t + dt) = X(t) + N(0, delta**2 * dt; t, t+dt)


    If `x0` is an array (or array-like), each value in `x0` is treated as
    an initial condition, and the value returned is a numpy array with one
    more dimension than `x0`.

    Arguments
    ---------
    x0 : float or numpy array (or something that can be converted to a numpy array
         using numpy.asarray(x0)).
        The initial condition(s) (i.e. position(s)) of the Brownian motion.
    n : int
        The number of steps to take.
    dt : float
        The time step.
    delta : float
        delta determines the "speed" of the Brownian motion.  The random variable
        of the position at time t, X(t), has a normal distribution whose mean is
        the position at time t=0 and whose variance is delta**2*t.
    out : numpy array or None
        If `out` is not None, it specifies the array in which to put the
        result.  If `out` is None, a new numpy array is created and returned.

    Returns
    -------
    A numpy array of floats with shape `x0.shape + (n,)`.
    
    Note that the initial value `x0` is not included in the returned array.
    """

    x0 = np.asarray(x0)

    # For each element of x0, generate a sample of n numbers from a
    # normal distribution.
    r = norm.rvs(size=x0.shape + (n,), scale=delta*sqrt(dt))

    # If `out` was not given, create an output array.
    if out is None:
        out = np.empty(r.shape)

    # This computes the Brownian motion by forming the cumulative sum of
    # the random samples. 
    np.cumsum(r, axis=-1, out=out)

    # Add the initial condition.
    out += np.expand_dims(x0, axis=-1)

    return out

import numpy
from pylab import plot, show, grid, xlabel, ylabel

# The Wiener process parameter.
deltaE = 10
deltaA = 50
# Total time.
T = 5.0
# Number of steps.
N = 50
# Time step size
dt = T/N
# Number of realizations to generate.
m = 5
# Create an empty array to store the realizations.
x = np.empty((m,N+1))
y = np.empty((m,N+1))
# Initial values of x.
x[:, 0] = priceE[len(priceE)-1]
y[:, 0] = priceA[len(priceA)-1]

brownian(x[:,0], N, dt, deltaE, out=x[:,1:])
brownian(y[:,0], N, dt, deltaA, out=y[:,1:])

tE = numpy.linspace(dateE[len(dateE)-1], dateE[len(dateE)-1]+5, N+1)
tA = numpy.linspace(dateA[len(dateA)-1], dateA[len(dateA)-1]+5, N+1)

# plotting the points 
plt.plot(dateE,priceE)
plt.plot(dateA,priceA)
plt.xlabel('Year') 
plt.ylabel('Price (USD)') 
plt.title('eBay vs Amazon\n1999 sampai 2019\ndengan sebuah prediksi metode Geometric Brownian Motion')
for k in range(m):
    plot(tE, x[k])
    plot(tA, y[k])
xlabel('t', fontsize=16)
ylabel('x', fontsize=16)
grid(True)
show()


